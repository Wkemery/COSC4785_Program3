%{
  /*
   * program3.lpp
   * Author: Wyatt Emery
   * Date: SEP 27, 2017
   *
   * COSC 4785, Homework3
   *
   */
  
  /* A note: 
   *  I used states for comments because I could not figure out how to do a 
   *  regex that didnt match completed multiline comments as incomplete 
   *  multiline comments. It added two extra states and a few extra rules, but
   *  I don't think it's too messy
   */
  
  #include"Lexeme.h" 
  #include"Node.h"
  #include"program3_bison.h"
  using namespace std;
  Lexeme token;
  int column = 1;
  
void yyerror(const char *string)
{
  if(strcmp(string, "syntax error") == 0 ) return;
  cerr << lines[yylval.token->line - 1] << endl;
    for(int i = 0; i < (yylval.token->column + - 1); i++)
  {
    cerr << " ";
  }
  cerr << "^" << endl;

  cerr << string << " Detected at: "<< yylval.token->line << ":" << yylval.token->column <<endl;

  return;
}
%}
%option outfile="program3_lex.cpp"
%option noyywrap
%option yylineno

WHITESPACE ([\t \n])
WORD (([a-zA-Z]|_)([a-zA-Z]|[0-9]|_)*)
PUNCTUATION [.,;()\[\]{}]

INVALIDCHARS [^!=<>+\-*\/;.,{}()% \t\n\[\]&]

VALIDNONWORD [!=<>+\-*\/;.,{}()% \t\n\[\]&]|(&&)|(\|\|)

INVALIDNONWORD [^!=<>+\-*\/;.,{}()% \t\n\[\]&\|]

%x ERROR
%x COMMENTS
%x ENDCOMMENTS
%x ERROR2
%%

"+" {
  //Plus Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("+");
  
  return PLUS; 
}
"-" {
  //Minus Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("-");

  
  return MINUS; 
}
"!" {
  //Not Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("!");
  
  return NOT; 
}

"==" {
  //== Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column+=2;
  lines[yylineno - 1].append("==");
  return DOUBEQ; 
}

"!=" {
  //!= Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column+=2;
  lines[yylineno - 1].append("!=");
  return NOTEQ; 
}

"<=" {
  //<= Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column+=2;
  lines[yylineno - 1].append("<=");
  return LESSEQ; 
}

">=" {
  //>= Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column+=2;
  lines[yylineno - 1].append(">=");
  return GREATEQ; 
}

"<" {
  //< Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("<");
  return LESS; 
}

">" {
  //> Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append(">");
  return GREAT; 
}

"||" {
  // || Operator
  yylval.token = new Lexeme;
  
  setToken(yytext, yylineno, column);
  column+=2;
  lines[yylineno - 1].append("||");
  return DOUBBAR; 
}

"*" {
  // * Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("*");
  return TIMES; 
}

"/" {
  // / Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("/");
  return DIVIDE; 
}

"%" {
  // % Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("%");
  return MOD; 
}

"&&" {
  //&& Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column+=2;
  lines[yylineno - 1].append("&&");
  return DOUBAND; 
}

(=) {
  //Assignment Operator
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("=");
  return ASSIGNOP; 
}

"." {
  //Dot  Operator
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append(".");
  return DOTOP; 
}

"," {
  //comma
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append(",");
  return COMMA; 
}

(;) {
  //Semi colon
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append(";");
  return SEMICO; 
}

"(" {
  //Left Paren
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("(");
  return LPAREN; 
}

")" {
  yylval.token = new Lexeme;
  
  //Right Paren
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append(")");
  return RPAREN; 
}

"\[" {
  //Left Bracket
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("[");
  return LBRACK; 
}

"\]" {
  //Rigth bracket
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("]");
  return RBRACK; 
}

"{" {
  // Left Brace
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("{");
  return LBRACE; 
}

"}" {
  //Right Brace
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column++;
  lines[yylineno - 1].append("}");
  return RBRACE; 
}

(class) {
  //class Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+=yyleng;
  lines[yylineno - 1].append("class");
  return CLASS; 
}

(this) {
  //this Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("this");
  return THIS; 
}
(if) {
  //if Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("if");
  return IF; 
}
(else) {
  //else Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("else");
  return ELSE; 
}
(while) {
  //while Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("while");
  return WHILE; 
}
(return) {
  //return Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("return");
  return RETURN; 
}

(print) {
  //print Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("print");
  return PRINT; 
}

(read) {
  //read Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("read");
  return READ; 
}

(void) {
  //void Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("void");
  return VOID; 
}

(new) {
  //new Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("new");
  return NEW; 
}

(null) {
  //null Keyword
  yylval.token = new Lexeme;
  
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("null");
  return NULLKEYWORD; 
}

(int) {
  //int keyword
  yylval.token = new Lexeme;
  setToken(NULL, yylineno, column);
  column+= yyleng;
  lines[yylineno - 1].append("int");
  return INT;
}

\/\/.*\n {
  // single line comment
  setToken(yytext, yylineno, column);
  column+= strlen(yytext);
}

[0-9]+ {
  //Number
  yylval.token = new Lexeme;
  setToken(yytext, yylineno, column);
  column+= token.value.length();
  lines[yylineno - 1].append(yytext);
  return NUM;
}

{WORD} {
  //identifier
  yylval.token = new Lexeme;
  setToken(yytext, yylineno, column);
  column+= token.value.length();
  lines[yylineno - 1].append(yytext);
  return IDENTIFIER; 
}

[ ]+ {
    
/*     setToken(yytext, yylineno, column); */
    column+= yyleng;
    lines[yylineno - 1].append(" ");
    
}

(\t)+ {
    
/*     setToken(yytext, yylineno, column); */
    column+= yyleng*8;
    lines[yylineno - 1].append("\t");
}

\n {
  
/*   setToken(yytext, yylineno, column);     */
  column = 1;
  lines.push_back("");
  
}

(\/\*) {
  column+= strlen(yytext);
  BEGIN(COMMENTS);
}

. {
  //found an error char, enter error state, ignore captured input
  //cout << "yytext:" << yytext << "end" <<endl; 
  yyless(0);
  BEGIN(ERROR); 
}

<ERROR>{INVALIDNONWORD}+ {
  //cout << "yytext:" << yytext << endl;
  yymore();
  BEGIN(ERROR2);
}


<ERROR>&|\| {
  //cout << "in err3 &" << endl;
  yymore();
}

<ERROR>.|\n {
  //cout << "HERE" << endl;
  yyless(strlen(yytext) - 1);
  BEGIN(INITIAL);
  setToken(yytext, yylineno, column);
  column+= token.value.length();
  return ERR;

}
 
<ERROR2>(&&)|(\|\|) {
  //cout << "yytext4:" << yytext << endl;
  yyless(strlen(yytext) - 2);
  BEGIN(INITIAL);
  setToken(yytext, yylineno, column);
  column+= token.value.length();
  return ERR;
}

<ERROR2>&|\| {
  //cout << "in & one" << endl;
  yymore();
  BEGIN(ERROR);
}


<ERROR2>.|\n {
  //cout << "yytextother:" << yytext << endl;
  yyless(strlen(yytext) - 1);
  BEGIN(INITIAL);
  setToken(yytext, yylineno, column);
  column+= token.value.length();
  return ERR;
}


<COMMENTS>([^\*\n])* {
  column+= strlen(yytext);
  BEGIN(ENDCOMMENTS);
}

<COMMENTS>\* {
  yyless(0);
  BEGIN(ENDCOMMENTS);
}

<COMMENTS>\n {
  column = 1;
}

<COMMENTS>(\/\*) {
  column+= strlen(yytext);
}

<ENDCOMMENTS>\n {
  column = 1;
  BEGIN(COMMENTS);
}

<ENDCOMMENTS>\*\/ {
  column+= strlen(yytext);
  BEGIN(INITIAL);
}

<ENDCOMMENTS>\* {
  column+= strlen(yytext);
  BEGIN(COMMENTS);
}

%%

